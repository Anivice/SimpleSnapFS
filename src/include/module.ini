template < typename Type >
Type _module_mgr::load_symbol(void* handle, const char* symbol)
{
    dlerror(); // clear existing errors
    Type func = (Type)dlsym(handle, symbol);
    const char* error = dlerror();
    if (error) {
        log(_log::LOG_ERROR, "Failed to load the symbol: ", error, "\n");
        dlclose(handle);
        throw fs_error_t(fs_error_t::SYMBOL_BOT_FOUND_IN_MODULE, *this);
    }
    return func;
}

template<typename... Args>
std::string _module_mgr::load(const std::string& module_path, Args&&... args)
{
    void* handle = dlopen(module_path.c_str(), RTLD_LAZY | RTLD_LOCAL);
    if (!handle) {
        log(_log::LOG_ERROR, "Failed to load the library: ", dlerror(), "\n");
        throw fs_error_t(fs_error_t::MODULE_LOADING_FAILED, *this);
    }

    auto get_module_description = load_symbol<get_module_description_t>(handle, "__get_module_description__");
    auto description = get_module_description();
    if (module_map.count(description.module_name)) {
        dlclose(handle);
        throw fs_error_t(fs_error_t::MODULE_EXISTS, *this);
    }

    auto module_initialize = load_symbol<invocation_handler_t>(handle, "module_initialization");
    int arg_count = sizeof...(Args);
    void* arg_array[] = { (void*)(description.module_name), reinterpret_cast<void*>(&args)... };
    module_initialize(arg_count, arg_array);

    module_map.emplace(description.module_name, handle);
    return description.module_name;
}

template<typename... Args>
void* _module_mgr::call(const std::string& module_name, const std::string& function, Args&&... args)
{
    auto it = module_map.find(module_name);
    if (it == module_map.end()) {
        throw fs_error_t(fs_error_t::NO_SUCH_MODULE, *this);
    }

    auto func = load_symbol<invocation_handler_t>(it->second, function.c_str());
    int arg_count = sizeof...(Args);
    void* arg_array[] = { (void*)(module_name.c_str()), reinterpret_cast<void*>(&args)... };
    return func(arg_count, arg_array);
}
